name: Release + RC Branch (npm/pnpm + github-script)

on:
  workflow_dispatch:
    inputs:
      bump:
        description: "Version bump size"
        required: true
        type: choice
        options: [Major, Minor, Patch]
      channel:
        description: "Release channel behavior for the versioned release"
        required: true
        type: choice
        options: [stable, beta, old]

permissions:
  contents: write
  issues: write

jobs:
  release-and-rc:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 24
          cache: npm

      - name: Configure git author
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Read current version
        id: versions_before
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            core.setOutput('old_version', pkg.version);

      - name: Decide bump arg + package manager
        id: bumpmeta
        uses: actions/github-script@v7
        env:
          BUMP: ${{ inputs.bump }}
        with:
          script: |
            const bump = process.env.BUMP.toLowerCase(); // major|minor|patch

            core.setOutput('bump', bump);

      - name: Install deps (npm)
        run: |
          npm -v
          npm ci

      - name: Bump version using npm version (workspace-aware)
        env:
          BUMP: ${{ steps.bumpmeta.outputs.bump }}
        run: |
          set -euo pipefail
          npm version "$BUMP" --no-git-tag-version

      - name: Read new version + compute RC version/branch + release flags
        id: meta
        uses: actions/github-script@v7
        env:
          BUMP: ${{ inputs.bump }}
          CHANNEL: ${{ inputs.channel }}
          OLD_VERSION: ${{ steps.versions_before.outputs.old_version }}
        with:
          script: |
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            const newVersion = pkg.version;

            const oldVersion = core.getInput('old_version') || process.env.OLD_VERSION;
            // but we set OLD_VERSION from env below (more reliable)

            function bumpPatch(v) {
              const m = v.match(/^(\d+)\.(\d+)\.(\d+)$/);
              if (!m) throw new Error(`Expected x.y.z, got: ${v}`);
              const maj = Number(m[1]), min = Number(m[2]), pat = Number(m[3]);
              return `${maj}.${min}.${pat + 1}`;
            }

            const rcVersion = bumpPatch(newVersion);
            const rcBranch = `release-candidate/${rcVersion}`;

            const bump = process.env.BUMP.toLowerCase(); // major|minor|patch
            const channel = process.env.CHANNEL; // stable|beta|old

            // Map "channel" -> GitHub Release flags for the versioned release
            // (old = not latest, not prerelease)
            const versionedRelease = {
              prerelease: channel === 'beta',
              make_latest: channel === 'stable' ? 'true' : 'false'
            };

            core.setOutput('new_version', newVersion);
            core.setOutput('rc_version', rcVersion);
            core.setOutput('rc_branch', rcBranch);
            core.setOutput('bump', bump);
            core.setOutput('channel', channel);
            core.setOutput('versioned_prerelease', String(versionedRelease.prerelease));
            core.setOutput('versioned_make_latest', String(versionedRelease.make_latest));

      - name: Commit version bump
        env:
          NEW_VERSION: ${{ steps.meta.outputs.new_version }}
        run: |
          set -euo pipefail
          git add package.json 2>/dev/null || true
          if git diff --cached --quiet; then
            echo "No version changes to commit."
          else
            git commit -m "ðŸš€ Release: ${NEW_VERSION}"
          fi

      - name: Create and push version tag
        env:
          NEW_VERSION: ${{ steps.meta.outputs.new_version }}
        run: |
          set -euo pipefail
          TAG="release/${NEW_VERSION}"

          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists. Aborting."
            exit 1
          fi

          git tag "$TAG"
          git push origin HEAD
          git push origin "$TAG"

      - name: Mock publish step
        env:
          NEW_VERSION: ${{ steps.meta.outputs.new_version }}
        run: |
          echo "MOCK: Publishing release/${NEW_VERSION} to npm registry..."
          echo "MOCK: done."

      # --- GitHub Releases: always create the versioned release,
      # and also create one moving "Stable" or "Beta" release tag depending on bump type:
      # - major/minor => create/update "Stable"
      # - patch      => create/update "Beta"
      - name: Create GitHub Releases (versioned + Stable/Beta alias)
        uses: actions/github-script@v7
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NEW_VERSION: ${{ steps.meta.outputs.new_version }}
          BUMP: ${{ steps.meta.outputs.bump }}
          VERSIONED_PRERELEASE: ${{ steps.meta.outputs.versioned_prerelease }}
          VERSIONED_MAKE_LATEST: ${{ steps.meta.outputs.versioned_make_latest }}
        with:
          script: |
            const newVersion = process.env.NEW_VERSION;
            const bump = process.env.BUMP; // major|minor|patch
            const tag = `release/${newVersion}`;

            const versionedPrerelease = process.env.VERSIONED_PRERELEASE === 'true';
            const versionedMakeLatest = process.env.VERSIONED_MAKE_LATEST; // "true" | "false"

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            async function getReleaseByTag(tagName) {
              try {
                const res = await github.rest.repos.getReleaseByTag({ owner, repo, tag: tagName });
                return res.data;
              } catch (e) {
                if (e.status === 404) return null;
                throw e;
              }
            }

            async function createOrUpdateRelease({ tagName, name, prerelease, make_latest }) {
              const existing = await getReleaseByTag(tagName);

              if (!existing) {
                await github.rest.repos.createRelease({
                  owner,
                  repo,
                  tag_name: tagName,
                  name,
                  prerelease,
                  make_latest,
                  generate_release_notes: true,
                });
                core.info(`Created release: ${name} (${tagName})`);
              } else {
                await github.rest.repos.updateRelease({
                  owner,
                  repo,
                  release_id: existing.id,
                  tag_name: tagName,
                  name,
                  prerelease,
                  make_latest,
                  // Note: updateRelease doesn't support generate_release_notes;
                  // keep existing body/notes as-is unless you want to regenerate manually.
                });
                core.info(`Updated release: ${name} (${tagName})`);
              }
            }

            // Versioned release (release/X.Y.Z)
            await createOrUpdateRelease({
              tagName: tag,
              name: tag,
              prerelease: versionedPrerelease,
              make_latest: versionedMakeLatest,
            });

            // Alias release/tag logic:
            // - major/minor => Stable
            // - patch       => Beta
            const alias = (bump === 'patch') ? 'beta' : 'stable';
            const aliasTag = alias;                 // moving tag: "stable" or "beta"
            const aliasName = alias === 'stable' ? 'Stable' : 'Beta';
            const aliasPrerelease = alias === 'beta';
            const aliasMakeLatest = alias === 'stable' ? 'true' : 'false';

            // Move the alias tag to the version tag commit (force-update the ref)
            // 1) Resolve the SHA of the version tag
            const tagRef = await github.rest.git.getRef({ owner, repo, ref: `tags/${tag}` });
            const tagObject = tagRef.data.object;

            // annotated tags point to a tag object; lightweight tags point to a commit
            let targetSha = tagObject.sha;
            if (tagObject.type === 'tag') {
              const annotated = await github.rest.git.getTag({ owner, repo, tag_sha: tagObject.sha });
              targetSha = annotated.data.object.sha; // commit sha
            }

            async function upsertTag(refName, sha) {
              const fullRef = `refs/tags/${refName}`;
              try {
                await github.rest.git.getRef({ owner, repo, ref: `tags/${refName}` });
                await github.rest.git.updateRef({ owner, repo, ref: `tags/${refName}`, sha, force: true });
                core.info(`Updated tag ${refName} -> ${sha}`);
              } catch (e) {
                if (e.status !== 404) throw e;
                await github.rest.git.createRef({ owner, repo, ref: fullRef, sha });
                core.info(`Created tag ${refName} -> ${sha}`);
              }
            }

            await upsertTag(aliasTag, targetSha);

            // Create/update alias release
            await createOrUpdateRelease({
              tagName: aliasTag,
              name: aliasName,
              prerelease: aliasPrerelease,
              make_latest: aliasMakeLatest,
            });

      - name: Create RC branch from version tag
        env:
          NEW_VERSION: ${{ steps.meta.outputs.new_version }}
          RC_BRANCH: ${{ steps.meta.outputs.rc_branch }}
        run: |
          set -euo pipefail
          TAG="release/${NEW_VERSION}"
          git checkout -b "${RC_BRANCH}" "${TAG}"
          git push -u origin "${RC_BRANCH}"

      - name: Update backport label to new stable target (uses RC version)
        uses: actions/github-script@v7
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OLD_VERSION: ${{ steps.versions_before.outputs.old_version }}
          RC_VERSION: ${{ steps.meta.outputs.rc_version }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const oldVersion = process.env.OLD_VERSION;
            const rcVersion = process.env.RC_VERSION;

            const oldLabel = `Backport to stable (${oldVersion})`;
            const newLabel = `Backport to stable (${rcVersion})`;

            // List labels (paginate)
            const labels = await github.paginate(github.rest.issues.listLabelsForRepo, { owner, repo, per_page: 100 });

            const oldFound = labels.find(l => l.name === oldLabel);
            const newFound = labels.find(l => l.name === newLabel);

            if (oldFound) {
              // Update/rename old -> new
              // issues.updateLabel uses current label name in URL, passed as "name"
              await github.rest.issues.updateLabel({
                owner,
                repo,
                name: oldLabel,
                new_name: newLabel,
              });
              core.info(`Renamed label: "${oldLabel}" -> "${newLabel}"`);
              return;
            }

            if (!newFound) {
              // Create new label if neither exists
              await github.rest.issues.createLabel({
                owner,
                repo,
                name: newLabel,
                color: "0E8A16",
                description: `Backport changes to stable ${rcVersion}`,
              });
              core.info(`Created label: "${newLabel}"`);
            } else {
              core.info(`Label already exists: "${newLabel}"`);
            }
